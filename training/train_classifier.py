"""
Train_classifier will load the training and testing
data, build the neural network graph, then train. It will
return and save the model as a .h5 file
"""
import pathlib
import argparse
import json
from keras.models import load_model
from keras.callbacks import History, ModelCheckpoint, EarlyStopping
from keras.preprocessing.image import ImageDataGenerator
import model

HISTORY = History()
HEIGHT = 224
WIDTH = 224
BATCH_SIZE = 128
EPOCHS = 10


def create_feed_data(directory):
    """
    Create batchs of feeding data by going directly
    to the images. Labels are generated by the file
    structure.
    INPUT: Directory of images. The directory should
    be structured as below:
    Parent
    |- Training
    |   |- Label
    |       |- Image
    |- Testing
        |- Label
            |- Image
    OUTPUT: keras training and validation generators
    """
    # Create the directory variables
    dataset_path = pathlib.Path(directory)
    train_path = dataset_path.joinpath("Training")
    test_path = dataset_path.joinpath("Testing")

    # Dimensions of the images
    img_width, img_height = WIDTH, HEIGHT

    # Obtain the number of images in the both
    # training and testing directory
    no_train_sam = 0
    no_test_sam = 0

    for label in train_path.iterdir():
        for image in label.iterdir():
            no_train_sam += 1

    for label in test_path.iterdir():
        for image in label.iterdir():
            no_test_sam += 1

    # Data augmentation
    train_datagen = ImageDataGenerator(
        rescale=1. / 255,
        shear_range=0.2,
        zoom_range=0.2)
    test_datagen = ImageDataGenerator(rescale=1. / 255)

    # Flow the images directly from the directory
    train_gen = train_datagen.flow_from_directory(
        train_path,
        target_size=(img_width, img_height),
        color_mode="grayscale",
        batch_size=BATCH_SIZE,
        class_mode='categorical')
    test_gen = test_datagen.flow_from_directory(
        test_path,
        target_size=(img_width, img_height),
        color_mode="grayscale",
        batch_size=BATCH_SIZE,
        class_mode='categorical')

    # Create the dictionary and write to a file for the classifier
    lab_dict = (test_gen.class_indices)
    # Flip the key-values
    lab_dict = dict((v, k) for k, v in lab_dict.items())

    return train_gen, test_gen, no_train_sam, no_test_sam, lab_dict


def build_model(classes):
    """Build the Keras neural network"""
    print("> Building Keras neural network...")
    network_model = model.mobile_net(classes=classes)
    return network_model


def fit_model(model, train_gen, test_gen, no_train, no_test, name):
    """
    Train the neural network with batch size of 200, 100 epochs,
    and print out training progress.
    """
    filename = 'weights.{epoch:02d}-{val_loss:.2f}-{val_acc:.2f}.hdf5'
    checkpointer = ModelCheckpoint(filepath=filename, verbose=1, period=1)
    early_stopping = EarlyStopping(monitor='val_acc',
                                   min_delta=0,
                                   patience=2,
                                   verbose=1,
                                   mode='auto')

    model.fit_generator(
        train_gen,
        steps_per_epoch=no_train // BATCH_SIZE,
        epochs=EPOCHS,
        validation_data=test_gen,
        validation_steps=no_test // BATCH_SIZE,
        callbacks=[checkpointer, early_stopping]
    )

    model.save(name)
    return model


if __name__ == "__main__":
    # Build up the argument to bring in an image
    AP = argparse.ArgumentParser()
    AP.add_argument("-m", "--model_path", help="path to an existing model",
                    required=False)
    AP.add_argument("-d", "--data_path", help="path to dataset", required=True)
    AP.add_argument("-s", "--save_path", help="path to save the final model",
                    required=True)
    AP.add_argument("-c", "--classes", help="number of classes", required=True)
    ARGS = vars(AP.parse_args())

    #############################
    # TRAIN
    #############################
    DIRECTORY = ARGS['data_path']
    MODEL_PATH = ARGS['model_path']
    MODEL_SAVE_NAME = ARGS['save_path']
    CLASSES = int(ARGS['classes'])
    DICT_PATH = '/home/alexander/Desktop/projects/ErmisOCR/src/classifier/char_labels.json'
    # Create training and testing data generators
    TRAIN_GEN, TEST_GEN, NO_TRAIN, NO_TEST, DICT = create_feed_data(DIRECTORY)

    # Print out the label dictionary
    with open(DICT_PATH, 'w') as file:
        json.dump(DICT, file)

    # Check if the model already exists
    # If not, build a new model file
    # If it does exist, load the model
    if MODEL_PATH is None:
        CHAR_MODEL = build_model(CLASSES)
    else:
        MODEL_DIRECTORY = pathlib.Path(MODEL_PATH)
        CHAR_MODEL = load_model(MODEL_DIRECTORY)

    HISTORY = fit_model(CHAR_MODEL,
                        TRAIN_GEN,
                        TEST_GEN,
                        NO_TRAIN,
                        NO_TEST,
                        MODEL_SAVE_NAME)
